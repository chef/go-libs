//
// Copyright 2020 Chef Software, Inc.
// Author: Salim Afiune <afiune@chef.io>
// Source: https://github.com/afiune/godist
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"os"
	"text/template"
	"time"
)

// A simple generator for creating easily distributable Go packages.
//
// This automation provides an easy way to generate variables that can be configured
// globally across multiple go packages, such as trademarks, product names, websites,
// etc. This generator should be defined as a `go:generate` comment and run at build
// time, using the `go generate` command.
//
// ### Example-1
// Our first example involves a simple use within a single main package. First, create
// a file called `dist_gen.go` with the following command:
//
// ```go
// package main
// //go:generate go run github.com/chef/go-libs/distgen
// ```
//
// The automation will deploy a file called `dist.go` with all the variables defined
// inside the JSON file `glob_dist.json` inside this repository. (See a real example
// at [example-main/](example-main).)
//
// ### Example-2
// In our second example involving multi-package, create a go package called `dist`
// with a file called `gen.go` with the following command:
//
// ```go
// package dist
// //go:generate go run github.com/chef/go-libs/distgen global.go dist
// ```
//
// This usage is for go projects that has multiple packages. By creating a single `dist`
// package inside your repository, you can import the generated package in any other
// packages. (See a real example at [example-multi-pkg/](example-multi-pkg).)
//
// ### Example-3
//
// To fully customize this automation, a user can provide a URL pointing to a custom JSON
// file as a third parameter to the `go:generate` directive. This custom JSON file should contain the
// global variables to generate. (See an example of a JSON file at
// [glob_dist.json](glob_dist.json).)
//
// ```go
// package dist
// //go:generate go run github.com/chef/go-libs/distgen global.go dist https://example.com/path/to/glob_dist.json
// ```

var (
	globalVariables map[string]string
	tplBuf          bytes.Buffer

	// the file name that this automation will generate (default `dist.go`)
	//
	// *customizable* (args:1)
	goFileName = "dist.go"

	// the go package to use inside the generated file.go (default: `main`)
	//
	// *customizable* (args:2)
	goPackage = "main"

	// a JSON format file where the global variables are defined
	// (by default the automation use the local `glob_dist.json`)
	//
	// *customizable* (args:3)
	globDistJson = "https://raw.github.com/chef/go-libs/master/distgen/glob_dist.json"
	// TODO @afiune use expeditor to run the gocode_generation helper from within an studio

	// a dist template to generate global variables
	// NOTE: @afiune in the future, if there are more customizations we
	// need, we could either modify this template or create new ones
	distTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
//
// file generated at: {{ .Timestamp }}
// using data from:   {{ .URL }}
// and generator:     https://github.com/chef/go-libs/distgen
//

package {{ .GoPackage }}

const (
{{- range $varName, $varValue := .GlobalVariables }}
  {{ printf "%v = %q" $varName $varValue }}
{{- end }}
)
`))
)

func fatal(msg string, err error) {
	fmt.Fprintf(os.Stderr, "%s: %s", msg, err.Error())
	os.Exit(1)
}

func main() {
	if len(os.Args) > 1 {
		goFileName = os.Args[1]
	}

	if len(os.Args) > 2 {
		goPackage = os.Args[2]
	}

	if len(os.Args) > 3 {
		globDistJson = os.Args[3]
	}

	rsp, err := http.Get(globDistJson)
	if err != nil {
		fatal("failed to get global variables file", err)
	}

	jsonRaw, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		fatal(fmt.Sprintf("failed to read body from %s", globDistJson), err)
	}

	err = json.Unmarshal(jsonRaw, &globalVariables)
	if err != nil {
		fatal("failed to unmarshal raw json", err)
	}

	err = distTemplate.Execute(&tplBuf, struct {
		Timestamp       time.Time
		URL             string
		GoPackage       string
		GlobalVariables map[string]string
	}{
		Timestamp:       time.Now(),
		URL:             globDistJson,
		GoPackage:       goPackage,
		GlobalVariables: globalVariables,
	})
	if err != nil {
		fatal("failed to write template", err)
	}

	f, err := os.Create(goFileName)
	if err != nil {
		fatal("failed to create file", err)
	}
	defer f.Close()

	// two reasons why we format the go template:
	// 1) to have a nice format :wink:
	// 2) also to verify that the generate go code is parsable/executable
	formatted, err := format.Source(tplBuf.Bytes())
	if err != nil {
		fatal("unable to format generate go template", err)
	}

	_, err = f.Write(formatted)
	if err != nil {
		fatal("failed to write file", err)
	}
}
